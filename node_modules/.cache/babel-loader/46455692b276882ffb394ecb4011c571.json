{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KEY_PREFIX } from './constants';\nexport default function createPersistoid(config) {\n  // defaults\n  const blacklist = config.blacklist || null;\n  const whitelist = config.whitelist || null;\n  const transforms = config.transforms || [];\n  const throttle = config.throttle || 0;\n  const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX}${config.key}`;\n  const storage = config.storage;\n  let serialize;\n\n  if (config.serialize === false) {\n    serialize = x => x;\n  } else if (typeof config.serialize === 'function') {\n    serialize = config.serialize;\n  } else {\n    serialize = defaultSerialize;\n  }\n\n  const writeFailHandler = config.writeFailHandler || null; // initialize stateful values\n\n  let lastState = {};\n  const stagedState = {};\n  const keysToProcess = [];\n  let timeIterator = null;\n  let writePromise = null;\n\n  const update = state => {\n    // add any changed keys to the queue\n    Object.keys(state).forEach(key => {\n      if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop\n\n      if (lastState[key] === state[key]) return; // value unchanged? noop\n\n      if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop\n\n      keysToProcess.push(key); // add key to queue\n    }); //if any key is missing in the new state which was present in the lastState,\n    //add it for processing too\n\n    Object.keys(lastState).forEach(key => {\n      if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) {\n        keysToProcess.push(key);\n      }\n    }); // start the time iterator if not running (read: throttle)\n\n    if (timeIterator === null) {\n      timeIterator = setInterval(processNextKey, throttle);\n    }\n\n    lastState = state;\n  };\n\n  function processNextKey() {\n    if (keysToProcess.length === 0) {\n      if (timeIterator) clearInterval(timeIterator);\n      timeIterator = null;\n      return;\n    }\n\n    const key = keysToProcess.shift();\n\n    if (key === undefined) {\n      return;\n    }\n\n    const endState = transforms.reduce((subState, transformer) => {\n      return transformer.in(subState, key, lastState);\n    }, lastState[key]);\n\n    if (endState !== undefined) {\n      try {\n        stagedState[key] = serialize(endState);\n      } catch (err) {\n        console.error('reduxjs-toolkit-persist/createPersistoid: error serializing state', err);\n      }\n    } else {\n      //if the endState is undefined, no need to persist the existing serialized content\n      delete stagedState[key];\n    }\n\n    if (keysToProcess.length === 0) {\n      writeStagedState();\n    }\n  }\n\n  function writeStagedState() {\n    // cleanup any removed keys just before write.\n    Object.keys(stagedState).forEach(key => {\n      if (lastState[key] === undefined) {\n        delete stagedState[key];\n      }\n    });\n    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);\n  }\n\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;\n    if (blacklist && blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n\n  function onWriteFail(err) {\n    // @TODO add fail handlers (typically storage full)\n    if (writeFailHandler) writeFailHandler(err);\n\n    if (err && process.env.NODE_ENV !== 'production') {\n      console.error('Error storing data', err);\n    }\n  }\n\n  const flush = () => {\n    while (keysToProcess.length !== 0) {\n      processNextKey();\n    }\n\n    return writePromise || Promise.resolve();\n  }; // return `persistoid`\n\n\n  return {\n    update,\n    flush\n  };\n} // @NOTE in the future this may be exposed via config\n\nfunction defaultSerialize(data) {\n  return JSON.stringify(data);\n}","map":{"version":3,"sources":["/home/wv/Desktop/GitRepos/Ecommerce/React-Redux-E_commerce/node_modules/reduxjs-toolkit-persist/es/createPersistoid.js"],"names":["KEY_PREFIX","createPersistoid","config","blacklist","whitelist","transforms","throttle","storageKey","keyPrefix","undefined","key","storage","serialize","x","defaultSerialize","writeFailHandler","lastState","stagedState","keysToProcess","timeIterator","writePromise","update","state","Object","keys","forEach","passWhitelistBlacklist","indexOf","push","setInterval","processNextKey","length","clearInterval","shift","endState","reduce","subState","transformer","in","err","console","error","writeStagedState","setItem","catch","onWriteFail","process","env","NODE_ENV","flush","Promise","resolve","data","JSON","stringify"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KEY_PREFIX } from './constants';\nexport default function createPersistoid(config) {\n    // defaults\n    const blacklist = config.blacklist || null;\n    const whitelist = config.whitelist || null;\n    const transforms = config.transforms || [];\n    const throttle = config.throttle || 0;\n    const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX}${config.key}`;\n    const storage = config.storage;\n    let serialize;\n    if (config.serialize === false) {\n        serialize = (x) => x;\n    }\n    else if (typeof config.serialize === 'function') {\n        serialize = config.serialize;\n    }\n    else {\n        serialize = defaultSerialize;\n    }\n    const writeFailHandler = config.writeFailHandler || null;\n    // initialize stateful values\n    let lastState = {};\n    const stagedState = {};\n    const keysToProcess = [];\n    let timeIterator = null;\n    let writePromise = null;\n    const update = (state) => {\n        // add any changed keys to the queue\n        Object.keys(state).forEach(key => {\n            if (!passWhitelistBlacklist(key))\n                return; // is keyspace ignored? noop\n            if (lastState[key] === state[key])\n                return; // value unchanged? noop\n            if (keysToProcess.indexOf(key) !== -1)\n                return; // is key already queued? noop\n            keysToProcess.push(key); // add key to queue\n        });\n        //if any key is missing in the new state which was present in the lastState,\n        //add it for processing too\n        Object.keys(lastState).forEach(key => {\n            if (state[key] === undefined &&\n                passWhitelistBlacklist(key) &&\n                keysToProcess.indexOf(key) === -1 &&\n                lastState[key] !== undefined) {\n                keysToProcess.push(key);\n            }\n        });\n        // start the time iterator if not running (read: throttle)\n        if (timeIterator === null) {\n            timeIterator = setInterval(processNextKey, throttle);\n        }\n        lastState = state;\n    };\n    function processNextKey() {\n        if (keysToProcess.length === 0) {\n            if (timeIterator)\n                clearInterval(timeIterator);\n            timeIterator = null;\n            return;\n        }\n        const key = keysToProcess.shift();\n        if (key === undefined) {\n            return;\n        }\n        const endState = transforms.reduce((subState, transformer) => {\n            return transformer.in(subState, key, lastState);\n        }, lastState[key]);\n        if (endState !== undefined) {\n            try {\n                stagedState[key] = serialize(endState);\n            }\n            catch (err) {\n                console.error('reduxjs-toolkit-persist/createPersistoid: error serializing state', err);\n            }\n        }\n        else {\n            //if the endState is undefined, no need to persist the existing serialized content\n            delete stagedState[key];\n        }\n        if (keysToProcess.length === 0) {\n            writeStagedState();\n        }\n    }\n    function writeStagedState() {\n        // cleanup any removed keys just before write.\n        Object.keys(stagedState).forEach(key => {\n            if (lastState[key] === undefined) {\n                delete stagedState[key];\n            }\n        });\n        writePromise = storage\n            .setItem(storageKey, serialize(stagedState))\n            .catch(onWriteFail);\n    }\n    function passWhitelistBlacklist(key) {\n        if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist')\n            return false;\n        if (blacklist && blacklist.indexOf(key) !== -1)\n            return false;\n        return true;\n    }\n    function onWriteFail(err) {\n        // @TODO add fail handlers (typically storage full)\n        if (writeFailHandler)\n            writeFailHandler(err);\n        if (err && process.env.NODE_ENV !== 'production') {\n            console.error('Error storing data', err);\n        }\n    }\n    const flush = () => {\n        while (keysToProcess.length !== 0) {\n            processNextKey();\n        }\n        return writePromise || Promise.resolve();\n    };\n    // return `persistoid`\n    return {\n        update,\n        flush,\n    };\n}\n// @NOTE in the future this may be exposed via config\nfunction defaultSerialize(data) {\n    return JSON.stringify(data);\n}\n"]},"metadata":{},"sourceType":"module"}